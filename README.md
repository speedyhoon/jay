# Jay

Jay aims to be the fastest serialization package written in [Go](https://go.dev) and
is an alternative to [JSON](), [Protocol Buffers](), [MessagePack]() and [Bebop]().

## TLDR;

##### Pros:

* Fastest Go serialization and deserialization binary format.
* No custom language to learn. Jay uses Go's built in [`ast`](https://pkg.go.dev) to find the exported structs you want
  in your existing codebase.
* No hassles between client and server. Generate the code once and share _(via a Go module or copy-paste)_.
* Options to generate code optimized for:
	* Least network bandwidth used _(10/100 networks)_ **OR**
	* Processing more requests per second _(higher CPU throughput)_.
* Doesn't introduce extra dependencies.

##### Cons:

* Needs to regenerate methods when Go structs are modified using the command line tool.
* Only written for the Go language.

## Speed

Unlike JSON, Jay's marshal and unmarshal functions are generated by a command line tool.
This significantly increases execution speed during runtime by removing type reflection.

Most structs with 10 fields can be easily serialized within 175 nanoseconds on old hardware _(Intel T6400 @ 2.0GHz with
GM45 GPU)_.

## Command line tool.

1. Execute the command line tool and specify which `.go` file contains the exported structs.
	For example, `type Car struct` is located within `main.go`.

```shell
cd <<my_project>>
jay main.go
```

2. Jay will then generate methods `MarshalJ` and `UnmarshalJ` in `jay.go` (the default output file).

3. The new methods can then be used. For example:

```go
package main

import "fmt"

type Car struct {
	ID          uint
	Make, Model string
	Auto        bool
}

func main() {
	car := Car{ID: 42, Make: "Ford", Model: "Escort", Auto: false}
	var src []byte
	src = car.MarshalJ()
	fmt.Println(src)

	var car2 Car
	err := car2.UnmarshalJ(src)
	fmt.Printf("err: %v, %+v", err, car2)
}
```

## Message format

Exported struct fields are concatenated together in binary format, delimited by each field's length.

High-throughput mode on a 64-bit system:

```
Auto, ID,               Make,      Model         = 21 bytes
[0,   42,0,0,0,0,0,0,0, 5,F,o,r,d, 6,E,s,c,o,r,t]
```

Low bandwidth mode:

```
Auto, ID,   Make,      Model         = 15 bytes
[0,   1,42, 5,F,o,r,d, 6,E,s,c,o,r,t]
```

## Supported types:

* `bool`
* `byte`
* `float32`, `float64`
* `int`, `int8`, `int16`, `int32`, `int64`
* `rune`
* `string`
* `uint`, `uint8`, `uint16`, `uint32`, `uint64`

## TODO

* `time.Time`
* slices, e.g.: (`[]string`)
* `map`, e.g.: (`map[string]uint`)
* pointers
* arrays, e.g.: (`[5]string`)
* GUID?
* complex?

## Not Supported

* `interface{}` requires adding reflection and/or type switches at a significant performance and complexity cost. Either
  use a different package or write your own function to convert the `interface{}` to one of the supported types (
  a `[]byte` might be the fastest option).
* Generics.

[//]: # (Go files are scanned using the command line tool to generate functions for exported structs.)


[//]: # (A fast serialization package alternative to JSON, MessagePack and Bebop. It outputs non-readable `[]byte` ideal for high throughput, using much less bandwidth than other options. )

[//]: # (Jay is similar to [Bebop]&#40;&#41; where the serialization functions are generated before compiling. This makes serialising and deserialising much faster than other options that use reflection during runtime like JSON.)


[//]: # (## Origins)

[//]: # (Credit to the creators of [Bebop]&#40;&#41; for creating an extremely fast serialization format.)

[//]: # (However, instead of using `.bop` schema files, `Jay` uses Go tags ``` `j:""` ``` to generate `Marshal` and `Unmarshal` functions for exported struct fields.)

[//]: # (`Jay` differs from Bebop to do away with the)
[//]: # (Using the command line tool,)
[//]: # (to and any struct that has exported fields with a tag containing `j:""` have a `Marshal` and `Unmarshal` function generated.)
[//]: # (without the `.bop` files.)

###### Name

The name `jay` gives tribute to a 17-year-old netbook with a stuck `j` key on the keyboard. Every boot looks like this

```
jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj
jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj
jjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjj
```