// Code generated by Jay; DO NOT EDIT.
package main

import (
	"bytes"
	"github.com/speedyhoon/jay"
)

func (c *Car) MarshalK() (b []byte) {
	l1, l2, l3 := len(c.Name)+1, len(c.CC)+1, len(c.Timing)+1
	l4 := jay.LenUint(c.Row)
	//b = make([]byte, 21 + l1+l2+l3+int(l4))
	b = make([]byte, 9+l1+l2+l3+int(l4))
	//l3 = 1 + 8 + 9 + l1+1 + l2+1 + l3+1
	b[0] = jay.Bool1(c.Auto)
	jay.WriteUint64(b[1:9], c.ID)
	at := int(9 + l4)
	jay.WriteUint(b[9:at], c.Row, l4)

	///*at +=*/ jay.WriteStringX(b[at:at+l1], c.Name, l1)
	//at += l1
	///*at +=*/ jay.WriteStringX(b[at:at+l2], c.CC, l2)
	//at += l2+1

	b[at] = byte(l1)
	at++
	if l1 != 0 {
		copy(b[at:at+l1], c.Name)
	}
	at += l1 - 1

	b[at] = byte(l2)
	at++
	if l2 != 0 {
		copy(b[at:at+l2], c.CC)
	}
	at += l2 - 1
	//jay.WriteStringX(b[at:at+l2], c.CC, l2)

	b[at] = byte(l3)
	at++
	if l3 != 0 {
		//	copy(b[at:at+l3], c.Timing)
		copy(b[at:], c.Timing)
	}
	//jay.WriteStringX(b[at:], c.Timing, l3)

	return
}

func (c *Car) MarshalL() (b []byte) {
	l1, l2, l3 := len(c.Name)+1, len(c.CC)+1, len(c.Timing)+1
	//l4 := jay.LenUint(c.Row)
	//b = make([]byte, 21 + l1+l2+l3+int(l4))
	b = make([]byte, 17+l1+l2+l3) //+int(l4))
	//l3 = 1 + 8 + 9 + l1+1 + l2+1 + l3+1
	b[0] = jay.Bool1(c.Auto)
	//jay.WriteUint64(b[1:9], c.ID)
	//at := int(9+l4)
	//at := 17
	//jay.WriteUintBytesXX(b[9:at], c.Row)

	b[1], b[2], b[3], b[4], b[5], b[6], b[7], b[8] = byte(c.ID), byte(c.ID>>8), byte(c.ID>>16), byte(c.ID>>24), byte(c.ID>>32), byte(c.ID>>40), byte(c.ID>>48), byte(c.ID>>56)
	//b[1] = byte(c.ID)
	//b[2] = byte(c.ID >> 8)
	//b[3] = byte(c.ID >> 16)
	//b[4] = byte(c.ID >> 24)
	//b[5] = byte(c.ID >> 32)
	//b[6] = byte(c.ID >> 40)
	//b[7] = byte(c.ID >> 48)
	//b[8] = byte(c.ID >> 56)

	//b[9], b[10], b[11], b[12], b[13], b[14], b[15], b[16] = byte(c.Row), byte(c.Row>>8), byte(c.Row>>16), byte(c.Row>>24), byte(c.Row>>32), byte(c.Row>>40), byte(c.Row>>48), byte(c.Row>>56)

	//b[9] = byte(c.Row)
	//b[10] = byte(c.Row >> 8)
	//b[11] = byte(c.Row >> 16)
	//b[12] = byte(c.Row >> 24)
	//b[13] = byte(c.Row >> 32)
	//b[14] = byte(c.Row >> 40)
	//b[15] = byte(c.Row >> 48)
	//b[16] = byte(c.Row >> 56)

	///*at +=*/ jay.WriteStringX(b[at:at+l1], c.Name, l1)
	//at += l1
	///*at +=*/ jay.WriteStringX(b[at:at+l2], c.CC, l2)
	//at += l2+1

	b[17] = byte(l1)
	//at++
	if l1 != 0 {
		copy(b[18:18+l1], c.Name)
	}
	at := 18 + l1 - 1

	b[at] = byte(l2)
	at++
	if l2 != 0 {
		copy(b[at:at+l2], c.CC)
	}
	at += l2 - 1
	//jay.WriteStringX(b[at:at+l2], c.CC, l2)

	b[at] = byte(l3)
	at++
	if l3 != 0 {
		//	copy(b[at:at+l3], c.Timing)
		copy(b[at:], c.Timing)
	}
	//jay.WriteStringX(b[at:], c.Timing, l3)

	return
}

func (c *Car) MarshalJ() (b []byte) {
	b = make([]byte, c.SizeJ())
	c.MarshalJTo(b)
	return b
}

func (c *Car) MarshalJ2() (b []byte) {
	//buf := bytes.NewBuffer(nil)
	buf := &bytes.Buffer{}
	jay.WriteBufUint64(buf, c.ID)
	jay.WriteBufUint(buf, c.Row)
	jay.WriteBufString(buf, c.Name)
	jay.WriteBufBool(buf, c.Auto)
	jay.WriteBufString(buf, c.CC)
	jay.WriteBufString(buf, c.Timing)

	//b = make([]byte, c.SizeJ())
	//c.MarshalJTo(b)
	return buf.Bytes()
}

func (c *Car) MarshalJTo(b []byte) {
	jay.WriteUint64(b[:8], c.ID)
	b[8] = jay.Bool1(c.Auto)
	at := 9 + jay.WriteUintBytesDEPRECATED(b[9:18], c.Row)
	at += jay.WriteString(b[17:], c.Name)
	at += jay.WriteString(b[at:], c.CC)
	at += jay.WriteString(b[at:], c.Timing)
	//c.Gearbox.MarshalJTo(b[at:])
}

func (c *Car) SizeJ() int {
	return 21 + len(c.Name) + len(c.CC) + len(c.Timing) + c.Gearbox.SizeJ()
}

func (c *Car) UnmarshalJ(b []byte) error {
	// TODO Check fixed size length SizeJ
	if len(b) <= 34 {
		return jay.ErrUnexpectedEOB
	}
	c.ID = jay.ReadUint64(b[:8])
	c.Auto = jay.ByteToBool(b[8])
	var at int
	c.Row, at = jay.ReadUint(b[9:19])
	at += 17
	var ok bool
	c.Name, at, ok = jay.ReadString(b[at:])
	if !ok {
		return jay.ErrUnexpectedEOB
	}
	c.CC, at, ok = jay.ReadString(b[at:])
	if !ok {
		return jay.ErrUnexpectedEOB
	}
	c.Timing, at, ok = jay.ReadString(b[at:])
	if !ok {
		return jay.ErrUnexpectedEOB
	}

	return c.Gearbox.UnmarshalJ(b[at:])
}

func (g *Gearbox) MarshalJ() (b []byte) {
	b = make([]byte, g.SizeJ())
	g.MarshalJTo(b)
	return b
}

func (g *Gearbox) MarshalJTo(b []byte) {
	b[0] = jay.Bool2(g.Sequential, g.Automatic)
	b[1] = g.Reverse
	at := jay.LenInt(g.Gears)
	jay.WriteInt(b[2:], g.Gears, at)
	at += 2
	at += jay.WriteString(b[at:], g.Model)
	jay.WriteString(b[at:], g.Manufacturer)
}

func (g *Gearbox) SizeJ() int {
	return 13 + len(g.Model) + len(g.Manufacturer)
}

func (g *Gearbox) UnmarshalJ(b []byte) error {
	if len(b) <= 13 { // TODO Hardcode fixed size length + SizeJ of children structs.
		return jay.ErrUnexpectedEOB
	}

	g.Sequential, g.Automatic = jay.ReadBool2(b[0])
	g.Reverse = b[1]
	var at int

	g.Gears, at = jay.ReadInt(b[2:])
	at += 2

	var ok bool
	g.Model, at, ok = jay.ReadStringX(b[at:], at)
	if !ok {
		return jay.ErrUnexpectedEOB
	}

	g.Manufacturer, at, ok = jay.ReadString(b[at:])
	if !ok {
		return jay.ErrUnexpectedEOB
	}
	return nil
}
